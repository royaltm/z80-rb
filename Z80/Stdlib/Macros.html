<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module Z80::Stdlib::Macros - ruby-Z80</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-clrmem">#clrmem</a>
    
    <li ><a href="#method-i-clrmem8">#clrmem8</a>
    
    <li ><a href="#method-i-clrmem_fastest">#clrmem_fastest</a>
    
    <li ><a href="#method-i-clrmem_quick">#clrmem_quick</a>
    
    <li ><a href="#method-i-memcpy">#memcpy</a>
    
    <li ><a href="#method-i-memcpy_quick">#memcpy_quick</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-Z80::Stdlib::Macros">
  <h1 id="module-Z80::Stdlib::Macros" class="module">
    module Z80::Stdlib::Macros
  </h1>

  <section class="description">
    
<h1 id="module-Z80::Stdlib::Macros-label-Z80-3A-3AStdlib+Macros."><a href="../Stdlib.html"><code>Z80::Stdlib</code></a> <a href="Macros.html"><code>Macros</code></a>.<span><a href="#module-Z80::Stdlib::Macros-label-Z80-3A-3AStdlib+Macros.">&para;</a> <a href="#top">&uarr;</a></span></h1>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-clrmem" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">clrmem</span><span
            class="method-args">(dest=hl, size=bc, value=0)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Clears memory at <code>dest</code> using LDIR instruction.</p>
<dl class="rdoc-list note-list"><dt><code>dest</code>
<dd>
<p>An address of the memory area to be cleared as an integer, a label, a pointer or <code>hl</code>.</p>
</dd><dt><code>size</code>
<dd>
<p>16bit size of area to be cleared as an integer, a label, a pointer or <code>bc</code>.</p>
</dd><dt><code>value</code>
<dd>
<p>A fill byte value as an integer, a label, a pointer or one of the registers: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>.</p>
</dd></dl>

<p>T-states: ~ 21/cleared byte.</p>

<p>Modifies: <code>bc</code>, <code>de</code>, <code>hl</code>, optionally <code>a</code> if <code>value</code> is an indirect (pointer) address.</p>
          
          

          
          <div class="method-source-code" id="clrmem-source">
            <pre><span class="ruby-comment"># File lib/z80/stdlib.rb, line 118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clrmem</span>(<span class="ruby-identifier">dest</span>=<span class="ruby-identifier">hl</span>, <span class="ruby-identifier">size</span>=<span class="ruby-identifier">bc</span>, <span class="ruby-identifier">value</span>=<span class="ruby-value">0</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">hl</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">size</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">bc</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">value</span>) <span class="ruby-keyword">or</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>,<span class="ruby-identifier">c</span>,<span class="ruby-identifier">d</span>,<span class="ruby-identifier">e</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">value</span>))
    <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
                <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">dest</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">hl</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">value</span>)
                <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">a</span>, <span class="ruby-identifier">value</span>
                <span class="ruby-identifier">ld</span>   [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">a</span>
            <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">ld</span>   [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">value</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">bc</span>
                <span class="ruby-identifier">dec</span>  <span class="ruby-identifier">bc</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">size</span>)
                <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">size</span>
                <span class="ruby-identifier">dec</span>  <span class="ruby-identifier">bc</span>
            <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
            <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">hl</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">dest</span>)
                <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>
                <span class="ruby-identifier">inc</span>  <span class="ruby-identifier">de</span>
            <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">de</span>, <span class="ruby-identifier">dest</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
            <span class="ruby-keyword">end</span>
                <span class="ruby-identifier">ldir</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clrmem8" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">clrmem8</span><span
            class="method-args">(dest=hl, size=b, value=0, rr:hl)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Clears max 256 bytes of memory at <code>dest</code>. Slower (does not use LDIR/LDDR) but involves less registers.</p>
<dl class="rdoc-list note-list"><dt><code>dest</code>
<dd>
<p>An address of the memory area to be cleared as an integer, a label, a pointer or same as <code>rr</code>.</p>
</dd><dt><code>size</code>
<dd>
<p>A size of area to be cleared or one of the 8bit registers.</p>
</dd><dt><code>value</code>
<dd>
<p>A fill byte value or one of the 8bit registers except <code>b</code>.</p>
</dd></dl>

<p>Options:</p>
<dl class="rdoc-list note-list"><dt><code>rr</code>
<dd>
<p>16bit address register: <code>de</code>, <code>hl</code>, <code>ix</code>, <code>iy</code>.</p>
</dd></dl>

<p>T-states: ~ 26/cleared byte. (~ 45 when <code>rr</code> is <code>ix</code> or <code>iy</code>)</p>

<p>Modifies: <code>a</code>, <code>b</code>, <code>rr</code>.</p>
          
          

          
          <div class="method-source-code" id="clrmem8-source">
            <pre><span class="ruby-comment"># File lib/z80/stdlib.rb, line 84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clrmem8</span>(<span class="ruby-identifier">dest</span>=<span class="ruby-identifier">hl</span>, <span class="ruby-identifier">size</span>=<span class="ruby-identifier">b</span>, <span class="ruby-identifier">value</span>=<span class="ruby-value">0</span>, <span class="ruby-value">rr:</span><span class="ruby-identifier">hl</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">rr</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">size</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">register?</span>(<span class="ruby-identifier">size</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">size</span>.<span class="ruby-identifier">bit8?</span>)) <span class="ruby-keyword">and</span>
                               ((<span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">size</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">a</span>) <span class="ruby-keyword">or</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">size</span>))) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">value</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">register?</span>(<span class="ruby-identifier">value</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">b</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">bit8?</span>)) <span class="ruby-keyword">and</span>
                               [<span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">ix</span>, <span class="ruby-identifier">iy</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">rr</span>)
    <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">size</span>)
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">a</span>, <span class="ruby-identifier">size</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">b</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">b</span>, <span class="ruby-identifier">size</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
                <span class="ruby-identifier">xor</span> <span class="ruby-identifier">a</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">a</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">a</span>, <span class="ruby-identifier">value</span>
        <span class="ruby-keyword">end</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">rr</span>, <span class="ruby-identifier">dest</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">rr</span>
        <span class="ruby-identifier">loop1</span>   <span class="ruby-identifier">ld</span>  [<span class="ruby-identifier">rr</span>], <span class="ruby-identifier">a</span>
                <span class="ruby-identifier">inc</span> <span class="ruby-identifier">rr</span>
                <span class="ruby-identifier">djnz</span> <span class="ruby-identifier">loop1</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clrmem_fastest" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">clrmem_fastest</span><span
            class="method-args">(address=hl, chunks_count=b, chunk_size=2, value=0, tt:hl, disable_intr:true, enable_intr:true, save_sp:true)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Clears a memory area using unrolled PUSH with a tight loop.</p>
<dl class="rdoc-list note-list"><dt><em>NOTE</em>
<dd>
<p>Interrupts should be disabled during execution of this code.</p>
</dd><dt><code>address</code>
<dd>
<p>An address of the next byte <em>AFTER</em> THE END of the memory area to be cleared. The address may be an integer, a label, a pointer or one of: <code>sp</code>, <code>hl</code>, <code>ix</code> or <code>iy</code>.</p>
</dd><dt><code>chunks_count</code>
<dd>
<p>The number of the unrolled push chunks between 1 and 256 as an integer, a label, a pointer or an 8-bit register.</p>
</dd><dt><code>chunk_size</code>
<dd>
<p>The size in bytes of the chunk of memory being cleared by unrolled PUSHes. It must be an <em>EVEN</em> integer number. Each 2 of <code>chunk_size</code> adds a 1 byte to the code.</p>
</dd><dt><code>value</code>
<dd>
<p>A 16-bit (a word) fill value as an integer, a label, a pointer or <code>tt</code>.</p>
</dd></dl>

<p>The total size being cleared equals to: <code>chunks_count</code> * <code>chunk_size</code>.</p>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>tt</code>
<dd>
<p>A 16-bit temporary register containing the filler value of the memory area to be cleared. One of: <code>hl</code>, <code>de</code> and optionally <code>bc</code> only if <code>chunks_count</code> is 1.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>A boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>A boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more uninterrupted actions.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>save_sp</code>
<dd>
<p>A boolean flag indicating that the <code>sp</code> register should be saved and restored. Otherwise <code>sp</code> will point to the beginning of the memory area being cleared.</p>
</dd></dl>
</li></ul>
<dl class="rdoc-list note-list"><dt><em>NOTE</em>
<dd>
<p>Restoring <code>sp</code> register uses self-modifying code.</p>
</dd></dl>

<p>T-states: ~ 5,5/cleared byte in a chunk + 13 between chunks + 8 after the last chunk.</p>

<p>Modifies: <code>tt</code>, <code>sp</code>, optionally <code>b</code> if <code>chunks_count</code> is not 1 and <code>a</code> if <code>chunks_count</code> is a pointer.</p>
          
          

          
          <div class="method-source-code" id="clrmem_fastest-source">
            <pre><span class="ruby-comment"># File lib/z80/stdlib.rb, line 210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clrmem_fastest</span>(<span class="ruby-identifier">address</span>=<span class="ruby-identifier">hl</span>, <span class="ruby-identifier">chunks_count</span>=<span class="ruby-identifier">b</span>, <span class="ruby-identifier">chunk_size</span>=<span class="ruby-value">2</span>, <span class="ruby-identifier">value</span>=<span class="ruby-value">0</span>, <span class="ruby-value">tt:</span><span class="ruby-identifier">hl</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">save_sp:</span><span class="ruby-keyword">true</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">address</span>) <span class="ruby-keyword">or</span> [<span class="ruby-identifier">sp</span>,<span class="ruby-identifier">hl</span>,<span class="ruby-identifier">ix</span>,<span class="ruby-identifier">iy</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">address</span>)) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">chunks_count</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">register?</span>(<span class="ruby-identifier">chunks_count</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">chunks_count</span>.<span class="ruby-identifier">bit8?</span>)) <span class="ruby-keyword">and</span>
                               (<span class="ruby-constant">Integer</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">chunk_size</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">value</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">tt</span>) <span class="ruby-keyword">and</span>
                               [<span class="ruby-identifier">bc</span>,<span class="ruby-identifier">de</span>,<span class="ruby-identifier">hl</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">tt</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;can&#39;t enable interrupts without restoring the sp register first&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span> <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">save_sp</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;chunk_size must be a positive and even integer number&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">chunk_size</span>.<span class="ruby-identifier">even?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">chunk_size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;chunks_count must be between 1 and 256&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">Integer</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">chunks_count</span> <span class="ruby-keyword">and</span>
                                                                     <span class="ruby-operator">!</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">256</span>).<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">chunks_count</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;tt must not be bc when chunks_count is not 1&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">tt</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">bc</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">chunks_count</span> <span class="ruby-operator">!=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">ld</span>  [<span class="ruby-identifier">restore_sp</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>], <span class="ruby-identifier">sp</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">save_sp</span>
        <span class="ruby-keyword">unless</span> <span class="ruby-identifier">chunks_count</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">chunks_count</span>)
                    <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">a</span>, <span class="ruby-identifier">chunks_count</span>
                    <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>
            <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">b</span>, <span class="ruby-identifier">chunks_count</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">chunks_count</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>
            <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">sp</span>, <span class="ruby-identifier">address</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">address</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">sp</span>
                    <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">tt</span>, <span class="ruby-identifier">value</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">tt</span>
        <span class="ruby-identifier">loop1</span>       <span class="ruby-identifier">label</span>
                    (<span class="ruby-identifier">chunk_size</span><span class="ruby-operator">/</span><span class="ruby-value">2</span>).<span class="ruby-identifier">times</span> { <span class="ruby-identifier">push</span> <span class="ruby-identifier">tt</span> }
                    <span class="ruby-identifier">djnz</span> <span class="ruby-identifier">loop1</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">chunks_count</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">restore_sp</span>  <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">sp</span>, <span class="ruby-value">0</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">save_sp</span>
                    <span class="ruby-identifier">ei</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clrmem_quick" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">clrmem_quick</span><span
            class="method-args">(dest=hl, size=1, value=0, rr:hl)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Clears memory at <code>dest</code> in a faster way using unrolled instructions.</p>
<dl class="rdoc-list note-list"><dt><code>dest</code>
<dd>
<p>An address of the memory area to be cleared as an integer, a label, a pointer or same as <code>rr</code>.</p>
</dd><dt><code>size</code>
<dd>
<p>A static size of area to be cleared. It should be a reasonably small positive integer number. There will be: <code>size</code> * 2 bytes added to the code.</p>
</dd><dt><code>value</code>
<dd>
<p>A fill byte value as an integer, a label, a pointer or one of the 8-bit registers.</p>
</dd></dl>

<p>Options:</p>
<dl class="rdoc-list note-list"><dt><code>rr</code>
<dd>
<p>16bit address register: <code>bc</code>, <code>de</code>, <code>hl</code>.</p>
</dd></dl>

<p>T-states: ~ 13/cleared byte.</p>

<p>Modifies: <code>a</code>, <code>rr</code>.</p>
          
          

          
          <div class="method-source-code" id="clrmem_quick-source">
            <pre><span class="ruby-comment"># File lib/z80/stdlib.rb, line 161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clrmem_quick</span>(<span class="ruby-identifier">dest</span>=<span class="ruby-identifier">hl</span>, <span class="ruby-identifier">size</span>=<span class="ruby-value">1</span>, <span class="ruby-identifier">value</span>=<span class="ruby-value">0</span>, <span class="ruby-value">rr:</span><span class="ruby-identifier">hl</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">rr</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-constant">Integer</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">size</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">value</span>) <span class="ruby-keyword">or</span> (<span class="ruby-identifier">register?</span>(<span class="ruby-identifier">value</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">bit8?</span>)) <span class="ruby-keyword">and</span>
                               [<span class="ruby-identifier">bc</span>, <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">rr</span>)
    <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
                <span class="ruby-identifier">xor</span> <span class="ruby-identifier">a</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">a</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">a</span>, <span class="ruby-identifier">value</span>
            <span class="ruby-keyword">end</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">rr</span>, <span class="ruby-identifier">dest</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">rr</span>
            (<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
                <span class="ruby-identifier">ld</span>  [<span class="ruby-identifier">rr</span>], <span class="ruby-identifier">a</span>
                <span class="ruby-identifier">inc</span> <span class="ruby-identifier">rr</span>
            <span class="ruby-keyword">end</span>
                <span class="ruby-identifier">ld</span>  [<span class="ruby-identifier">rr</span>], <span class="ruby-identifier">a</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-memcpy" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">memcpy</span><span
            class="method-args">(dest=de, source=hl, size=bc, reverse: nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copies <code>size</code> bytes from memory area <code>source</code> to memory area <code>dest</code>.</p>
<dl class="rdoc-list note-list"><dt><code>dest</code>
<dd>
<p>A destination address as an integer, a label, a pointer or <code>de</code>.</p>
</dd><dt><code>source</code>
<dd>
<p>A destination address as an integer, a label, a pointer or <code>hl</code>.</p>
</dd><dt><code>size</code>
<dd>
<p>A size of area to be copied as an integer, a label, a pointer or <code>bc</code>.</p>
</dd></dl>

<p>Options:</p>
<dl class="rdoc-list note-list"><dt><code>reverse</code>
<dd>
<p>A flag if <code>true</code> the routine uses LDDR, otherwise uses LDIR.</p>
</dd><dt><em>NOTE</em>
<dd>
<p>In case <code>reverse</code> is <code>true</code> the <code>dest</code> and <code>source</code> should address the last byte of the destinetion and source memory area to be copied.</p>
</dd></dl>

<p>If <code>reverse</code> is <code>nil</code> and <code>dest</code> and <code>source</code> and <code>size</code> are integers or labels (but not pointers) detects if source and destination memory overlaps and applies LDIR or LDDR during code generation.</p>

<p>Modifies: <code>bc</code>, <code>de</code>, <code>hl</code>.</p>
          
          

          
          <div class="method-source-code" id="memcpy-source">
            <pre><span class="ruby-comment"># File lib/z80/stdlib.rb, line 258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">memcpy</span>(<span class="ruby-identifier">dest</span>=<span class="ruby-identifier">de</span>, <span class="ruby-identifier">source</span>=<span class="ruby-identifier">hl</span>, <span class="ruby-identifier">size</span>=<span class="ruby-identifier">bc</span>, <span class="ruby-value">reverse:</span> <span class="ruby-keyword">nil</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">de</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">source</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">source</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">hl</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">size</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">bc</span>)
    <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">reverse</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">address?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">address?</span>(<span class="ruby-identifier">source</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">address?</span>(<span class="ruby-identifier">size</span>) <span class="ruby-keyword">and</span>
                             <span class="ruby-operator">!</span><span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">source</span>) <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">size</span>)
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">size</span>
            <span class="ruby-identifier">select</span>(<span class="ruby-identifier">dest</span>, <span class="ruby-identifier">source</span>, <span class="ruby-identifier">size</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">dst</span>,<span class="ruby-identifier">src</span>,<span class="ruby-identifier">sz</span><span class="ruby-operator">|</span> <span class="ruby-identifier">dst</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">src</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">src</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sz</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">dst</span> }.<span class="ruby-identifier">then</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">_</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">de</span>, <span class="ruby-identifier">dest</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">source</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">lddr</span>
            <span class="ruby-keyword">end</span>.<span class="ruby-identifier">else</span> <span class="ruby-keyword">do</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">de</span>, <span class="ruby-identifier">dest</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">source</span>
                <span class="ruby-identifier">ldir</span>
            <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">size</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">bc</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">de</span>, <span class="ruby-identifier">dest</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">de</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">source</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">source</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">hl</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">reverse</span>
                <span class="ruby-identifier">lddr</span>
            <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">ldir</span>
            <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-memcpy_quick" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">memcpy_quick</span><span
            class="method-args">(dest=de, source=hl, size=1, reverse: nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copies <code>size</code> bytes from memory area <code>source</code> to memory area <code>dest</code> using unrolled LDI/LDD.</p>
<dl class="rdoc-list note-list"><dt><code>dest</code>
<dd>
<p>A destination address as an integer, a label, a pointer or <code>de</code>.</p>
</dd><dt><code>source</code>
<dd>
<p>A destination address as an integer, a label, a pointer or <code>hl</code>.</p>
</dd><dt><code>size</code>
<dd>
<p>A static size of area to be copied. It should be a reasonably small positive integer number.</p>
</dd></dl>

<p>Options:</p>
<dl class="rdoc-list note-list"><dt><code>reverse</code>
<dd>
<p>A flag if <code>true</code> the routine uses LDD, otherwise uses LDI.</p>
</dd><dt><em>NOTE</em>
<dd>
<p>In case <code>reverse</code> is <code>true</code> the <code>dest</code> and <code>source</code> should address the last byte of the destinetion and source memory area to be copied.</p>
</dd></dl>

<p>If <code>reverse</code> is <code>nil</code> and <code>dest</code> and <code>source</code> are integers or labels (but not pointers) detects if source and destination memory overlaps and applies LDI or LDD during code generation.</p>

<p>Modifies: <code>bc</code>, <code>de</code>, <code>hl</code>.</p>
          
          

          
          <div class="method-source-code" id="memcpy_quick-source">
            <pre><span class="ruby-comment"># File lib/z80/stdlib.rb, line 304</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">memcpy_quick</span>(<span class="ruby-identifier">dest</span>=<span class="ruby-identifier">de</span>, <span class="ruby-identifier">source</span>=<span class="ruby-identifier">hl</span>, <span class="ruby-identifier">size</span>=<span class="ruby-value">1</span>, <span class="ruby-value">reverse:</span> <span class="ruby-keyword">nil</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span> <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">de</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-identifier">address?</span>(<span class="ruby-identifier">source</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">source</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">hl</span>) <span class="ruby-keyword">and</span>
                               (<span class="ruby-constant">Integer</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">size</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">reverse</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">address?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">and</span> <span class="ruby-identifier">address?</span>(<span class="ruby-identifier">source</span>) <span class="ruby-keyword">and</span>
                              <span class="ruby-operator">!</span><span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">dest</span>) <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">pointer?</span>(<span class="ruby-identifier">source</span>)
            <span class="ruby-identifier">select</span>(<span class="ruby-identifier">dest</span>, <span class="ruby-identifier">source</span>, <span class="ruby-identifier">size</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">dst</span>,<span class="ruby-identifier">src</span>,<span class="ruby-identifier">sz</span><span class="ruby-operator">|</span> <span class="ruby-identifier">dst</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">src</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">src</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sz</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">dst</span> }.<span class="ruby-identifier">then</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">_</span><span class="ruby-operator">|</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">de</span>, <span class="ruby-identifier">dest</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">source</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">size</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">ldd</span> }
            <span class="ruby-keyword">end</span>.<span class="ruby-identifier">else</span> <span class="ruby-keyword">do</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">de</span>, <span class="ruby-identifier">dest</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">source</span>
                <span class="ruby-identifier">size</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">ldi</span> }
            <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">de</span>, <span class="ruby-identifier">dest</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">dest</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">de</span>
                <span class="ruby-identifier">ld</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">source</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">source</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">hl</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">reverse</span>
                <span class="ruby-identifier">size</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">ldd</span> }
            <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">size</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">ldi</span> }
            <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

