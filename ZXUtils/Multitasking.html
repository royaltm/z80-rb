<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class ZXUtils::Multitasking - ruby-Z80</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/navigation.js" defer></script>
<script src="../js/search.js" defer></script>
<script src="../js/search_index.js" defer></script>
<script src="../js/searcher.js" defer></script>
<script src="../js/darkfish.js" defer></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#class-ZXUtils::Multitasking-label-ZXUtils-3A-3AMultitasking">ZXUtils::Multitasking</a>
    <li><a href="#class-ZXUtils::Multitasking-label-Task+guide">Task guide</a>
    <li><a href="#class-ZXUtils::Multitasking-label-Machine+code+for+tasks+should+respect+the+following+restrictions-3A">Machine code for tasks should respect the following restrictions:</a>
    <li><a href="#class-ZXUtils::Multitasking-label-Task+code+recommendations-3A">Task code recommendations:</a>
    <li><a href="#class-ZXUtils::Multitasking-label-Task+initialization-3A">Task initialization:</a>
    <li><a href="#class-ZXUtils::Multitasking-label-Task+registers-3A">Task registers:</a>
    <li><a href="#class-ZXUtils::Multitasking-label-Memory+map-3A">Memory map:</a>
    <li><a href="#class-ZXUtils::Multitasking-label-ZX+Basic+API">ZX Basic API</a>
    <li><a href="#class-ZXUtils::Multitasking-label-Task+API">Task API</a>
  </ul>
</div>


  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="../Object.html">Object</a>
</div>

    
<div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
    <li><a class="include" href="../Z80.html">Z80</a>
    <li><a class="include" href="../Z80/TAP.html">Z80::TAP</a>
  </ul>
</div>

    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-kernel_org">::kernel_org</a>
    <li ><a href="#method-c-new_kernel">::new_kernel</a>
    <li ><a href="#method-i-api">#api</a>
    <li ><a href="#method-i-init_multitasking">#init_multitasking</a>
    <li ><a href="#method-i-rdoc_mark_find_def_fn_arg">#rdoc_mark_find_def_fn_arg</a>
    <li ><a href="#method-i-stack_space_free">#stack_space_free</a>
    <li ><a href="#method-i-task_yield">#task_yield</a>
    <li ><a href="#method-i-terminate">#terminate</a>
    <li ><a href="#method-i-unknown">#unknown</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-ZXUtils::Multitasking">
  <h1 id="class-ZXUtils::Multitasking" class="class">
    class ZXUtils::Multitasking
  </h1>

  <section class="description">
    
<h1 id="class-ZXUtils::Multitasking-label-ZXUtils-3A-3AMultitasking"><a href="Multitasking.html"><code>ZXUtils::Multitasking</code></a><span><a href="#class-ZXUtils::Multitasking-label-ZXUtils-3A-3AMultitasking">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>Run machine code programs (a.k.a. “tasks”) in parallel with the ZX Spectrum&#39;s Basic.</p>

<p>This class contains <a href="Multitasking/Macros.html"><code>Macros</code></a> and kernel labels for tasks and the kernel code.</p>

<p>The “tasks” are machine code programs that are run in parallel as opposed to system programs which are run in sequence.</p>

<p>The <a href="Multitasking.html"><code>Multitasking</code></a> module provides a kernel that handles a task creation, execution switching and termination. Switching between tasks is handled on each maskable interrupt or on demand. Each task is being provided with its own stack space. System programs such as Basic or user machine code (USR) use the system stack as usual. An execution of a system program is intertwined with an execution of each task in turn. Tasks as well as system programs may “yield” its execution early with an API call.</p>

<h3 id="class-ZXUtils::Multitasking-label-Task+guide">Task guide<span><a href="#class-ZXUtils::Multitasking-label-Task+guide">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="class-ZXUtils::Multitasking-label-Machine+code+for+tasks+should+respect+the+following+restrictions-3A">Machine code for tasks should respect the following restrictions:<span><a href="#class-ZXUtils::Multitasking-label-Machine+code+for+tasks+should+respect+the+following+restrictions-3A">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p>Task&#39;s code shouldn&#39;t change interrupt handler (no tampering with register <code>I</code> and no <code>IM</code> instructions).</p>
</li><li>
<p>Task&#39;s stacks may be moved up when other tasks terminate - tasks shouldn&#39;t store pointers to its own stack entries.</p>
</li><li>
<p>When using <code>SP</code> for other purposes always disable interrupts and restore <code>SP</code> to the previous value before enabling interrupts.</p>
</li><li>
<p>At the task initialization, <code>IY</code> register is set to tasks&#39; <code>stack_bot + 128</code> address and may be used as a stack pointer frame for tasks&#39; variables as the value of <code>IY</code> register is being moved along with the stack.</p>
</li></ul>

<h4 id="class-ZXUtils::Multitasking-label-Task+code+recommendations-3A">Task code recommendations:<span><a href="#class-ZXUtils::Multitasking-label-Task+code+recommendations-3A">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p>Avoid modifying ZX Basic variables or using ROM routines that modifies them.</p>
</li><li>
<p>To yield execution instead of using <code>halt</code> use <code>call task_yield</code>.</p>
</li><li>
<p>To terminate itself the task should either jump to <code>terminate</code> or just <code>ret</code>.</p>
</li><li>
<p>Tasks may store local variables using indexing register <code>IY</code> - see below.</p>
</li></ul>

<h4 id="class-ZXUtils::Multitasking-label-Task+initialization-3A">Task initialization:<span><a href="#class-ZXUtils::Multitasking-label-Task+initialization-3A">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Each task receives its own, dedicated stack space. Whenever the execution context is being switched, next task&#39;s <code>SP</code> register address is being checked against its own stack&#39;s boundary. If it points below the designated address space the whole multitasking is being terminated (panic) and the control  is returned to the system.</p>

<p>Tasks may also use bottom of the stack space for task-local variables storing them via <code>IY</code> register which addresses the 128&#39;th byte above the stack&#39;s bottom. So to be on the safe side tasks should start  allocating variables from <code>[IY-128]</code> up.</p>

<h5 id="class-ZXUtils::Multitasking-label-Task+registers-3A">Task registers:<span><a href="#class-ZXUtils::Multitasking-label-Task+registers-3A">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>Registers may be used freely with some limitations (<code>SP</code>, <code>IY</code>) mentioned above. When the task starts, the CPU registers hold:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>SP</code>
<dd>
<p>The task&#39;s end of stack - 2. <code>SP</code> points to the address of <code>terminate</code> routine, so invoking <code>ret</code> will terminate the task.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>IY</code>
<dd>
<p>The task&#39;s bottom of stack + 128.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>IX</code>
<dd>
<p>The task&#39;s stack size.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>HL</code>
<dd>
<p>The task&#39;s initial <code>PC</code>.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>BC</code>
<dd>
<p>The task&#39;s id.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>DE</code>
<dd>
<p>The <code>terminate</code> routine address.</p>
</dd></dl>
</li></ul>

<h3 id="class-ZXUtils::Multitasking-label-Memory+map-3A">Memory map:<span><a href="#class-ZXUtils::Multitasking-label-Memory+map-3A">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre>                          TaskVars
+---------+-------------+------------+-----------+-----------+-------------+--------------+--------------+
| BASIC   | Display and | ZX Printer | System    | ZX Basic  | Tasks&#39; Code | Multitasking | Multitasking |
|  ROM    |  Attributes |     Buffer | Variables | Workspace |    and Data |  Stack Space |       Kernel |
+---------+-------------+------------+-----------+-----------+-------------+--------------+--------------+
^         ^             ^            ^           ^           ^             ^              ^              ^
$0000     $4000         $5B00        $5C00       $5CB6       RAMTOP        |              |         P_RAMT
                        mtvars                                             stack_bot      stack_end</pre>

<h3 id="class-ZXUtils::Multitasking-label-ZX+Basic+API">ZX Basic API<span><a href="#class-ZXUtils::Multitasking-label-ZX+Basic+API">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre>REM Setup:
REM Initializes or resets multitasking.
REM Returns the number of bytes available for new tasks&#39; stacks.
PRINT USR api

REM Spawns a task:
1 DEF FN m(a,s) = USR api

LET tid = FN m(address,stacksize)

REM Terminates a task:
2 DEF FN t(t) = USR api

REM Returns the number of bytes available for new tasks&#39; stacks after the task is terminated.
PRINT FN t(tid)

REM Returns the number of bytes available for new tasks&#39; stacks.
3 DEF FN f() = USR api

PRINT FN f()</pre>
<dl class="rdoc-list note-list"><dt><code>address</code>
<dd>
<p>Must be a task&#39;s machine code entry point address.</p>
</dd><dt><code>stacksize</code>
<dd>
<p>Must be an even number of bytes, at least 42.</p>
</dd><dt><code>tid</code>
<dd>
<p>Must be a number returned from <code>FN m(a,s)</code>.</p>
</dd></dl>

<p><code>Setup</code> must be invoked at least once before any other function is used. It can also be called to terminate all tasks.</p>

<p><code>Spawn</code> will result in “4 Out of memory” error if there is not enough room for a task info entry or stack space.</p>

<p>“A Invalid argument” error may also be reported when arguments are incorrect.</p>

<h3 id="class-ZXUtils::Multitasking-label-Task+API">Task API<span><a href="#class-ZXUtils::Multitasking-label-Task+API">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">import</span>        <span class="ruby-constant">ZXUtils</span><span class="ruby-operator">::</span><span class="ruby-constant">Multitasking</span>, <span class="ruby-value">code:</span> <span class="ruby-keyword">false</span>, <span class="ruby-value">macros:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">labels:</span> <span class="ruby-constant">ZXUtils</span><span class="ruby-operator">::</span><span class="ruby-constant">Multitasking</span>.<span class="ruby-identifier">kernel_org</span>

              <span class="ruby-comment"># ...</span>
              <span class="ruby-comment"># instead of invoking halt, call task_yield</span>
              <span class="ruby-identifier">call</span> <span class="ruby-identifier">task_yield</span>
              <span class="ruby-comment"># ...</span>
              <span class="ruby-comment"># to terminate:</span>
              <span class="ruby-identifier">jp</span>   <span class="ruby-identifier">terminate</span>
              <span class="ruby-comment"># or when a stack is depleted just:</span>
              <span class="ruby-identifier">ret</span>
</pre>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">


    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
        <dt id="MT_STACK_BOT">MT_STACK_BOT
        <dd><p>Bottom of the multitasking stack space.</p>
        <dt id="MT_VARS">MT_VARS
        <dd><p>An address of the task variables (<a href="Multitasking/TaskVars.html"><code>TaskVars</code></a>). Can be moved elsewhere if ZX Printer is needed.</p>
        <dt id="TASK_QUEUE_MAX">TASK_QUEUE_MAX
        <dd><p>A hard limit on the number of tasks. Should not be enlarged if <a href="Multitasking.html#MT_VARS"><code>MT_VARS</code></a> are placed inside ZX Printer Buffer.</p>
      </dl>
    </section>



     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-kernel_org" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">kernel_org</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>The <a href="Multitasking.html"><code>Multitasking</code></a> kernel code start address.</p>

          <div class="method-source-code" id="kernel_org-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 160</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">kernel_org</span>
  <span class="ruby-value">0x10000</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">code</span>.<span class="ruby-identifier">bytesize</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-c-new_kernel" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">new_kernel</span><span
            class="method-args">(*args, **opts)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Instantiate <a href="Multitasking.html"><code>Multitasking</code></a> kernel with the proper code address.</p>

          <div class="method-source-code" id="new_kernel-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">new_kernel</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">opts</span>)
  <span class="ruby-identifier">new</span> <span class="ruby-identifier">kernel_org</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">opts</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-api" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            USR api
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            DEF FN m(a,s)=USR api
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            DEF FN t(t)=USR api
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            DEF FN f()=USR api
          </span>
        </div>

        <div class="method-description">
          <p>ZX Basic API</p>

<p>This endpoint should be invoked from the ZX Basic directly via USR or indirectly via FN.</p>

<pre>LET stackFreeBytes=USR api: REM Initializes multitasking.

1 DEF FN m(a,s)=USR api: REM Spawns a task
LET tid=FN m(address,stacksize)

2 DEF FN t(t)=USR api: REM Terminates a task
LET stackFreeBytes=FN t(tid)

3 DEF FN f() = USR api: REM Returns the number of bytes available for new tasks&#39; stacks.</pre>

          <div class="method-source-code" id="api-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 414</span>
<span class="ruby-identifier">ns</span> <span class="ruby-value">:api</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">call</span> <span class="ruby-identifier">find_def_fn_arg</span>            <span class="ruby-comment"># is this an FN call with arguments?</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">Z</span>, <span class="ruby-identifier">new_or_terminate</span>        <span class="ruby-comment"># yes: skip to new_or_terminate</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">C</span>, <span class="ruby-identifier">init_multitasking</span>       <span class="ruby-comment"># called via USR</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-init_multitasking" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            call init_multitasking
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Initializes multitasking.</p>
<dl class="rdoc-list note-list"><dt><em>NOTE</em>
<dd>
<p>This routine must never be called from a task!</p>
</dd></dl>

<p>Clears all tasks, sets global variables and enables the custom interrupt handler.</p>

<p>Modifies: <code>af</code>, <code>bc</code>, <code>de</code>, <code>hl</code>, <code>i</code>, <code>IFF</code>.</p>

          <div class="method-source-code" id="init_multitasking-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 478</span>
<span class="ruby-identifier">ns</span> <span class="ruby-value">:init_multitasking</span>, <span class="ruby-value">use:</span> <span class="ruby-value">:mtvars</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">di</span>                              <span class="ruby-comment"># prevent switching</span>
                    <span class="ruby-identifier">clrmem</span> <span class="ruby-identifier">mtvars</span>, <span class="ruby-operator">+</span><span class="ruby-identifier">mtvars</span>          <span class="ruby-comment"># remove all tasks</span>
  <span class="ruby-identifier">init_stack_end</span>    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">initial_stack_end</span>
                    <span class="ruby-identifier">ld</span>   [<span class="ruby-identifier">mtvars</span>.<span class="ruby-identifier">stack_end</span>], <span class="ruby-identifier">hl</span>     <span class="ruby-comment"># initialize stack_end</span>
  <span class="ruby-identifier">init_stack_bottom</span> <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">initial_stack_bot</span>
                    <span class="ruby-identifier">ld</span>   [<span class="ruby-identifier">mtvars</span>.<span class="ruby-identifier">stack_bot</span>], <span class="ruby-identifier">hl</span>     <span class="ruby-comment"># initialize stack_bot</span>
                    <span class="ruby-identifier">call</span> <span class="ruby-identifier">stack_space_free</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">a</span>, <span class="ruby-value">0x3B</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">i</span>, <span class="ruby-identifier">a</span>                       <span class="ruby-comment"># load the accumulator with unused (filled with 255) page in rom.</span>
                    <span class="ruby-identifier">im2</span>
                    <span class="ruby-identifier">ei</span>
                    <span class="ruby-identifier">ret</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-rdoc_mark_find_def_fn_arg" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            call find_def_fn_arg
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Looks for a first DEF FN argument value address.</p>
<dl class="rdoc-list note-list"><dt><em>NOTE</em>
<dd>
<p>This routine must never be called from a task!</p>
</dd></dl>

<p>If an argument is found the <code>hl</code> registers will address an argument&#39;s FP-value and the ZF flag will be set (Z). If the code wasn&#39;t invoked via the FN function call, the CF flag will be set instead (C).</p>

<p>Modifies: <code>af</code> and <code>hl</code>.</p>

          <div class="method-source-code" id="rdoc_mark_find_def_fn_arg-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 719</span>
<span class="ruby-identifier">ns</span> <span class="ruby-value">:rdoc_mark_find_def_fn_arg</span>, <span class="ruby-value">merge:</span> <span class="ruby-keyword">true</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">find_def_fn_arg</span>     <span class="ruby-identifier">find_def_fn_args</span> <span class="ruby-value">1</span>, <span class="ruby-value">cf_on_direct:</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-stack_space_free" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            call stack_space_free
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns (in <code>bc</code>) how many bytes are available in multitasking stack space for new tasks. Reports an OOM error if the task variables are corrupted or uninitialized.</p>

<p>Modifies: <code>af</code>, <code>bc</code>, <code>de</code>, <code>hl</code>.</p>

          <div class="method-source-code" id="stack_space_free-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 427</span>
<span class="ruby-identifier">ns</span> <span class="ruby-value">:stack_space_free</span>, <span class="ruby-value">use:</span> <span class="ruby-value">:mtvars</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">mtvars</span>.<span class="ruby-identifier">stack_end</span> <span class="ruby-operator">-</span> (<span class="ruby-operator">+</span><span class="ruby-constant">TaskInfo</span> <span class="ruby-operator">-</span> <span class="ruby-value">3</span>)
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">bc</span>, <span class="ruby-operator">+</span><span class="ruby-constant">TaskInfo</span> <span class="ruby-operator">-</span> <span class="ruby-value">3</span>       <span class="ruby-comment"># begin with mtvars.stack_end as the 1st task&#39;s stack_end</span>
  <span class="ruby-identifier">search_last</span>       <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>                  <span class="ruby-comment"># skip task.stack_save</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">e</span>, [<span class="ruby-identifier">hl</span>]                 <span class="ruby-comment"># task.stack_bot</span>
                    <span class="ruby-identifier">inc</span>  <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">d</span>, [<span class="ruby-identifier">hl</span>]                 <span class="ruby-comment"># task.stack_bot</span>
                    <span class="ruby-identifier">inc</span>  <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">a</span>, [<span class="ruby-identifier">hl</span>]                 <span class="ruby-comment"># task.tid</span>
                    <span class="ruby-identifier">inc</span>  <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ora</span>  [<span class="ruby-identifier">hl</span>]                    <span class="ruby-comment"># task.tid</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">NZ</span>, <span class="ruby-identifier">search_last</span>         <span class="ruby-comment"># some tid?</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">hl</span>, [<span class="ruby-identifier">mtvars</span>.<span class="ruby-identifier">stack_bot</span>]  <span class="ruby-comment"># DE: tasks[last].stack_bot</span>
                    <span class="ruby-identifier">ex</span>   <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">sbc</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">de</span>                  <span class="ruby-comment"># task.stack_bot - mtvars.stack_bot</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">C</span>, <span class="ruby-identifier">ei_report_oom</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ret</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-task_yield" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            call task_yield
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Yields task execution.</p>

<p>Tasks or system programs should call this endpoint instead of invoking halt. This will switch the execution context to the next task in the queue immediately. The execution of the calling task will resume when its turn will come.</p>

<p>Modifies: nothing. Requires at least 22 bytes on a machine stack to be available.</p>

          <div class="method-source-code" id="task_yield-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 734</span>
<span class="ruby-identifier">ns</span> <span class="ruby-value">:task_yield</span>      <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">di</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">bc</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">de</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">af</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">ix</span>
                    <span class="ruby-identifier">ex</span>   <span class="ruby-identifier">af</span>, <span class="ruby-identifier">af</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">af</span>
                    <span class="ruby-identifier">exx</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">bc</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">de</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">iy</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-identifier">handle_interrupts</span>.<span class="ruby-identifier">task_yield</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-terminate" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            jp terminate
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Terminates the current task.</p>

<p>Tasks may jump to this endpoint directly to terminate themselves. If called or jumped to from a system program and not from a task reports “0 OK” error.</p>

<p><code>ret</code> instruction from a task will actually jump back here.</p>

          <div class="method-source-code" id="terminate-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 617</span>
<span class="ruby-identifier">ns</span> <span class="ruby-value">:terminate</span>, <span class="ruby-value">use:</span> <span class="ruby-value">:mtvars</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">di</span>                            <span class="ruby-comment"># prevent switching</span>
                    <span class="ruby-identifier">check_current_task</span>            <span class="ruby-comment"># HL: -&gt; task.stack_bot, CF: 0</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">Z</span>, <span class="ruby-identifier">ei_report_ok</span>          <span class="ruby-comment"># called not from a task</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">sp</span>, [<span class="ruby-identifier">mtvars</span>.<span class="ruby-identifier">system_sp</span>]
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">switch_to_sys</span>        <span class="ruby-comment"># store switch_to_sys as a</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">bc</span>                       <span class="ruby-comment"># ret address</span>
                    <span class="ruby-value">3</span>.<span class="ruby-identifier">times</span> { <span class="ruby-identifier">dec</span> <span class="ruby-identifier">hl</span> }
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">b</span>, [<span class="ruby-identifier">hl</span>]
                    <span class="ruby-identifier">dec</span>  <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">c</span>, [<span class="ruby-identifier">hl</span>]                  <span class="ruby-comment"># BC: task&#39;s tid</span>
  <span class="ruby-comment"># Find task info entry by tid.</span>
  <span class="ruby-identifier">search_terminate</span>  <span class="ruby-identifier">ld</span>   [<span class="ruby-identifier">restore_sp</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>], <span class="ruby-identifier">sp</span>     <span class="ruby-comment"># BC: tid, save SP to be restored at the end</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">sp</span>, <span class="ruby-identifier">mtvars</span>.<span class="ruby-identifier">stack_end</span>     <span class="ruby-comment"># search for a task.tid == BC</span>
  <span class="ruby-identifier">search_loop</span>       <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">de</span>                       <span class="ruby-comment"># DE: stack_end</span>
                    <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">hl</span>                       <span class="ruby-comment"># HL: task.tid</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">a</span>, <span class="ruby-identifier">l</span>
                    <span class="ruby-identifier">ora</span>  <span class="ruby-identifier">h</span>                        <span class="ruby-comment"># CF: 0</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">Z</span>, <span class="ruby-identifier">task_not_found</span>        <span class="ruby-comment"># task.tid == 0</span>
                    <span class="ruby-identifier">sbc</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># task.tid == BC</span>
                    <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">hl</span>                       <span class="ruby-comment"># HL: task.stack_save (ignored)</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">NZ</span>, <span class="ruby-identifier">search_loop</span>          <span class="ruby-comment"># SP: -&gt; task.stack_bot, CF: 0</span>
  <span class="ruby-comment"># Found task info entry to terminate. Now we need to:</span>
  <span class="ruby-comment"># - Update the following tasks&#39; stack_save and stack_bot pointers.</span>
  <span class="ruby-comment"># - Move the following tasks&#39; info entries up.</span>
  <span class="ruby-comment"># - Move the following tasks&#39; stacks down.</span>
  <span class="ruby-identifier">terminate_found</span>   <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">bc</span>                       <span class="ruby-comment"># BC: stack_bot, DE: stack_end, SP: -&gt; task[tid + 1], CF: 0</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">ix</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># IX: stack_bot</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">de</span>                   <span class="ruby-comment"># HL: stack_end</span>
                    <span class="ruby-identifier">sbc</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># HL: stack size = stack_end - stack_bot</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">hl</span>                   <span class="ruby-comment"># BC: stack size</span>
                    <span class="ruby-identifier">exx</span>                           <span class="ruby-comment"># B&#39;C&#39;: stack size, D&#39;E&#39;: stack_end</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-value">0</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">sp</span>                   <span class="ruby-comment"># HL: task[tid + 1], DE: 0</span>
                    <span class="ruby-identifier">ex</span>   <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>                   <span class="ruby-comment"># HL: 0, DE: task[tid + 1]</span>
                    <span class="ruby-identifier">exx</span>                           <span class="ruby-comment"># BC: stack size, DE: stack_end, D&#39;E&#39;: task[tid + 1], H&#39;L&#39;: 0</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-identifier">update_pointers</span>.<span class="ruby-identifier">start</span>
  <span class="ruby-comment"># Increment all the following task&#39;s pointers by the terminated task&#39;s stack size and get the last task&#39;s stack_bot.</span>
  <span class="ruby-identifier">ns</span> <span class="ruby-value">:update_pointers</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">hl</span>                       <span class="ruby-comment"># task.stack_save</span>
                    <span class="ruby-identifier">ld</span>   [<span class="ruby-identifier">restore_sp</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>], <span class="ruby-identifier">sp</span>     <span class="ruby-comment"># save SP</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">sp</span>, <span class="ruby-identifier">hl</span>                   <span class="ruby-comment"># SP: task&#39;s SP</span>
                    <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">iy</span>                       <span class="ruby-comment"># IY: task&#39;s IY</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">iy</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># add reclaimed delta to IY</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">iy</span>
    <span class="ruby-identifier">restore_sp</span>      <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">sp</span>, <span class="ruby-value">0</span>                    <span class="ruby-comment"># SP: restore</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># add reclaimed delta to stack_save</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">hl</span>                       <span class="ruby-comment"># task.stack_save</span>
                    <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">hl</span>                       <span class="ruby-comment"># task.stack_bot</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># add reclaimed delta to stack_bot</span>
                    <span class="ruby-identifier">push</span> <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">de</span>                       <span class="ruby-comment"># updated task.stack_bot</span>
    <span class="ruby-identifier">start</span>           <span class="ruby-identifier">pop</span>  <span class="ruby-identifier">hl</span>                       <span class="ruby-comment"># task.tid</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">a</span>, <span class="ruby-identifier">l</span>
                    <span class="ruby-identifier">ora</span>  <span class="ruby-identifier">h</span>                        <span class="ruby-comment"># CF=0</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">NZ</span>, <span class="ruby-identifier">update_pointers</span>
  <span class="ruby-keyword">end</span>                                             <span class="ruby-comment"># SP: -&gt; task[ntasks].stack_save, BC: terminated task stack size, DE: task[ntasks].stack_bot + stack size</span>
  <span class="ruby-comment"># Move the following tasks&#39; info entries + terminator up.</span>
                    <span class="ruby-identifier">exx</span>                           <span class="ruby-comment"># DE: task[tid + 1], HL: 0</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">sp</span>                   <span class="ruby-comment"># HL: SP, CF: 0</span>
                    <span class="ruby-identifier">sbc</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">de</span>                   <span class="ruby-comment"># HL: SP - task[tid + 1]</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">hl</span>                   <span class="ruby-comment"># BC: SP - task[tid + 1]</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">de</span>                   <span class="ruby-comment"># HL: task[tid + 1]</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">sp</span>, <span class="ruby-operator">-</span>(<span class="ruby-operator">+</span><span class="ruby-constant">TaskInfo</span>)
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">sp</span>                   <span class="ruby-comment"># HL: task[tid]</span>
                    <span class="ruby-identifier">ex</span>   <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>                   <span class="ruby-comment"># DE: task[tid], HL: task[tid + 1]</span>
                    <span class="ruby-identifier">ldir</span>
                    <span class="ruby-identifier">exx</span>                           <span class="ruby-comment"># BC: stack size, DE: task[ntasks-1].stack_bot + tid stack size</span>
  <span class="ruby-comment"># Move the following tasks&#39; stacks down.</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">sp</span>, <span class="ruby-identifier">ix</span>                   <span class="ruby-comment"># SP: task[tid].stack_bot</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># tid stack size</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">sp</span>                   <span class="ruby-comment"># HL: task[tid].stack_end</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">hl</span>                   <span class="ruby-comment"># BC: task[tid].stack_end</span>
                    <span class="ruby-identifier">sbc</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">de</span>                   <span class="ruby-comment"># task[tid].stack_end - (HL: task[ntasks-1].stack_bot + tid stack size)</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">Z</span>, <span class="ruby-identifier">skip_reclaim_stk</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">de</span>, <span class="ruby-identifier">bc</span>                   <span class="ruby-comment"># DE: task[tid].stack_end</span>
                    <span class="ruby-identifier">ld16</span> <span class="ruby-identifier">bc</span>, <span class="ruby-identifier">hl</span>                   <span class="ruby-comment"># BC: task[ntasks-1].stack_bot + tid stack size - task[tid].stack_end</span>
                    <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-value">-1</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">sp</span>                   <span class="ruby-comment"># HL: task[tid].stack_bot - 1</span>
                    <span class="ruby-identifier">dec</span>  <span class="ruby-identifier">de</span>                       <span class="ruby-comment"># DE: task[tid].stack_end - 1</span>
                    <span class="ruby-identifier">lddr</span>
  <span class="ruby-comment"># That&#39;s it, now restore SP and just return.</span>
  <span class="ruby-identifier">skip_reclaim_stk</span>  <span class="ruby-identifier">label</span>
  <span class="ruby-identifier">task_not_found</span>    <span class="ruby-identifier">label</span>
  <span class="ruby-identifier">restore_sp</span>        <span class="ruby-identifier">ld</span>   <span class="ruby-identifier">sp</span>, <span class="ruby-value">0</span>
                    <span class="ruby-identifier">ret</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-unknown" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            call get_uint_arg
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Attempts to read a positive 16-bit integer from a FP-value addressed by <code>hl</code>.</p>
<dl class="rdoc-list note-list"><dt><em>NOTE</em>
<dd>
<p>This routine must never be called from a task!</p>
</dd></dl>

<p>Input:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an address of a FP-value.</p>
</dd></dl>
</li></ul>

<p>On success <code>de</code> holds a value and <code>hl</code> will be incremented past the last FP-value&#39;s byte. On failure reports “A Invalid argument” error.</p>

<p>Modifies: <code>af</code>, <code>de</code>, <code>hl</code>.</p>

          <div class="method-source-code" id="unknown-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking.rb, line 462</span>
<span class="ruby-identifier">get_uint_arg</span>      <span class="ruby-identifier">read_positive_int_value</span> <span class="ruby-identifier">d</span>, <span class="ruby-identifier">e</span>
</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

