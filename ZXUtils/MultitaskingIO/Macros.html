<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module ZXUtils::MultitaskingIO::Macros - ruby-Z80</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="../Multitasking/Macros.html">ZXUtils::Multitasking::Macros</a>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-mtio_drain">#mtio_drain</a>
    
    <li ><a href="#method-i-mtio_getc">#mtio_getc</a>
    
    <li ><a href="#method-i-mtio_gets">#mtio_gets</a>
    
    <li ><a href="#method-i-mtio_putc">#mtio_putc</a>
    
    <li ><a href="#method-i-mtio_puts">#mtio_puts</a>
    
    <li ><a href="#method-i-mtio_ready-3F">#mtio_ready?</a>
    
    <li ><a href="#method-i-mtio_wait">#mtio_wait</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-ZXUtils::MultitaskingIO::Macros">
  <h1 id="module-ZXUtils::MultitaskingIO::Macros" class="module">
    module ZXUtils::MultitaskingIO::Macros
  </h1>

  <section class="description">
    
<h2 id="module-ZXUtils::MultitaskingIO::Macros-label-ZXUtils-3A-3AMultitaskingIO+Macros+for+tasks."><a href="../MultitaskingIO.html"><code>ZXUtils::MultitaskingIO</code></a> <a href="Macros.html"><code>Macros</code></a> for tasks.<span><a href="#module-ZXUtils::MultitaskingIO::Macros-label-ZXUtils-3A-3AMultitaskingIO+Macros+for+tasks.">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Most of the routines created by <a href="Macros.html"><code>MultitaskingIO::Macros</code></a> expects an I/O buffer handle in the <code>hl</code> register pair. The buffer handle may be obtained by calling one of the kernel functions:</p>
<ul><li>
<p><a href="../MultitaskingIO.html#method-i-find_io_handles"><code>MultitaskingIO.find_io_handles</code></a>,</p>
</li><li>
<p><a href="../MultitaskingIO.html#method-i-find_input_handle"><code>MultitaskingIO.find_input_handle</code></a>,</p>
</li><li>
<p><a href="../MultitaskingIO.html#method-i-find_output_handle"><code>MultitaskingIO.find_output_handle</code></a>.</p>
</li></ul>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-mtio_drain" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mtio_drain</span><span
            class="method-args">(disable_intr:true, enable_intr:true)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Drains the I/O buffer.</p>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more atomic actions.</p>
</dd></dl>
</li></ul>

<p>Expects:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an I/O buffer handle.</p>
</dd></dl>
</li></ul>

<p>Removes all the pending data from an I/O buffer.</p>

<p>Modifies: <code>af</code>, preserves: <code>hl</code>.</p>
          
          

          
          <div class="method-source-code" id="mtio_drain-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking_io.rb, line 438</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mtio_drain</span>(<span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eoc</span><span class="ruby-operator">|</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, [<span class="ruby-identifier">hl</span>] <span class="ruby-comment"># outoffs</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ei</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span>
                    <span class="ruby-identifier">ld</span>    [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">a</span> <span class="ruby-comment"># inpoffs</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mtio_getc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mtio_getc</span><span
            class="method-args">(char=e, tt:bc, not_ready: :eoc, subroutine: true, preserve_hl:true, disable_intr:true, enable_intr:true, mtyield: task_yield)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Reads a single character from the I/O buffer. Arguments:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>char</code>
<dd>
<p>an 8 bit register which should receive a code if the character read.</p>
</dd></dl>
</li></ul>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>tt</code>
<dd>
<p>an 16 bit register for temporary use.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>not_ready</code>
<dd>
<p>what to do when a character can&#39;t be read. A symbol <code>:eoc</code> to just signal the failure with the CF flag reset (NC) and the ZF flag set (Z). A symbol <code>:wait</code> to wait for the character to become available. A label or an address to jump to when the character is not available.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>subroutine</code>
<dd>
<p>if the routine should terminate with a <code>ret</code> instruction.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>preserve_hl</code>
<dd>
<p>if the routine should preserve the <code>hl</code> register via the stack.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more atomic actions.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>mtyield</code>
<dd>
<p>should contain an address of the kernel routine: <code>task_yield</code>.</p>
</dd></dl>
</li></ul>

<p>Expects:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an I/O buffer handle.</p>
</dd></dl>
</li></ul>

<p>On success the CF flag is set and a register <code>char</code> contains a read character.</p>

<p>Modifies: <code>af</code>, <code>hl</code>, <code>tt</code>, <code>char</code>, optionally preserves: <code>hl</code> on the machine stack.</p>
          
          

          
          <div class="method-source-code" id="mtio_getc-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking_io.rb, line 472</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mtio_getc</span>(<span class="ruby-identifier">char</span>=<span class="ruby-identifier">e</span>, <span class="ruby-value">tt:</span><span class="ruby-identifier">bc</span>, <span class="ruby-value">not_ready:</span> <span class="ruby-value">:eoc</span>, <span class="ruby-value">subroutine:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">preserve_hl:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">mtyield:</span> <span class="ruby-identifier">task_yield</span>)
  <span class="ruby-identifier">th</span>, <span class="ruby-identifier">tl</span> = <span class="ruby-identifier">tt</span>.<span class="ruby-identifier">split</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;char must not be a tl or th or h or l&quot;</span> <span class="ruby-keyword">if</span> [<span class="ruby-identifier">h</span>,<span class="ruby-identifier">l</span>,<span class="ruby-identifier">th</span>,<span class="ruby-identifier">tl</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">char</span>)
  <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">push</span>  <span class="ruby-identifier">hl</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">preserve_hl</span>
      <span class="ruby-identifier">repeat</span>        <span class="ruby-identifier">label</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">tl</span>, [<span class="ruby-identifier">hl</span>] <span class="ruby-comment"># inpoffs</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, [<span class="ruby-identifier">hl</span>]  <span class="ruby-comment"># outoffs</span>
                    <span class="ruby-identifier">cp</span>    <span class="ruby-identifier">tl</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">not_ready</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:eoc</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">enable_intr</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">preserve_hl</span>
                    <span class="ruby-identifier">ret</span>   <span class="ruby-constant">Z</span>
      <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">eop</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:wait</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">wait_busy</span>
      <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NZ</span>, <span class="ruby-identifier">skip</span>
                    <span class="ruby-identifier">call</span>  <span class="ruby-identifier">mtyield</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-identifier">repeat</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jp</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">not_ready</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">skip</span>            <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">tl</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ld</span>    [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">tl</span> <span class="ruby-comment"># inpoffs</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>       <span class="ruby-comment"># outoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">th</span>, <span class="ruby-value">-1</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">tt</span>   <span class="ruby-comment"># CF=1</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">char</span>, [<span class="ruby-identifier">hl</span>]
    <span class="ruby-identifier">eop</span>             <span class="ruby-identifier">label</span>
                    <span class="ruby-identifier">ei</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span>
                    <span class="ruby-identifier">pop</span>   <span class="ruby-identifier">hl</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">preserve_hl</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
                    <span class="ruby-identifier">ret</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">not_ready</span> <span class="ruby-operator">==</span> <span class="ruby-value">:wait</span>
    <span class="ruby-identifier">wait_busy</span>       <span class="ruby-identifier">call</span>  <span class="ruby-identifier">mtyield</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-identifier">repeat</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mtio_gets" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mtio_gets</span><span
            class="method-args">(nchars=a, check_nchars_zero:true, subroutine:true, disable_intr:true, enable_intr:true, mtyield: task_yield)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Reads a string of characters from the I/O buffer.</p>

<p>Arguments:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>nchars</code>
<dd>
<p>a number 1..255 or accumulator with a number of characters to read.</p>
</dd></dl>
</li></ul>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>tt</code>
<dd>
<p>an 16 bit register for temporary use.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>check_nchars_zero</code>
<dd>
<p>a boolean indicating if the accumulator should be checked against 0.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>subroutine</code>
<dd>
<p>if the routine should terminate with a <code>ret</code> instruction.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more atomic actions.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>mtyield</code>
<dd>
<p>should contain an address of the kernel routine: <code>task_yield</code>.</p>
</dd></dl>
</li></ul>

<p>Expects:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an I/O buffer handle.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>de</code>
<dd>
<p>an address where the string will be stored.</p>
</dd></dl>
</li></ul>

<p>On success accumulator contains the number of characters successfully read. If its value is 0 the ZF flag is also set indicating that no characters has been read at all. Preserves <code>hl</code> registers. <code>de</code> will be incremented by the number of characters read.</p>

<p>Modifies: <code>af</code>, <code>af&#39;</code>, <code>de</code>, <code>bc</code> and uses stack to preserve <code>hl</code>.</p>
          
          

          
          <div class="method-source-code" id="mtio_gets-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking_io.rb, line 625</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mtio_gets</span>(<span class="ruby-identifier">nchars</span>=<span class="ruby-identifier">a</span>, <span class="ruby-value">check_nchars_zero:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">subroutine:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">mtyield:</span> <span class="ruby-identifier">task_yield</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;nchars must be accumulator or an integer: 1..255&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">nchars</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a</span> <span class="ruby-keyword">or</span> (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">255</span>).<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">nchars</span>)
  <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eoc</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nchars</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">check_nchars_zero</span>
                    <span class="ruby-identifier">anda</span>  <span class="ruby-identifier">a</span>         <span class="ruby-comment"># nchars == 0</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
                    <span class="ruby-identifier">ret</span>   <span class="ruby-constant">Z</span>
        <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">eoc</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
                    <span class="ruby-identifier">ex</span>    <span class="ruby-identifier">af</span>, <span class="ruby-identifier">af</span>
    <span class="ruby-keyword">end</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; outoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, [<span class="ruby-identifier">hl</span>]   <span class="ruby-comment"># outoffs</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; inpoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, [<span class="ruby-identifier">hl</span>]   <span class="ruby-comment"># inpoffs</span>
                    <span class="ruby-identifier">sub</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># a: nchars ready</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">eop</span>    <span class="ruby-comment"># nothing to read</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># inpoffs + 1</span>
                    <span class="ruby-identifier">push</span>  <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; inpoffs</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; outoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-value">-1</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># b: nchars ready</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nchars</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a</span>
                    <span class="ruby-identifier">ex</span>    <span class="ruby-identifier">af</span>, <span class="ruby-identifier">af</span>
    <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, <span class="ruby-identifier">nchars</span>
    <span class="ruby-keyword">end</span>
                    <span class="ruby-identifier">cp</span>    <span class="ruby-identifier">b</span>         <span class="ruby-comment"># nchars &lt; nchars ready</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NC</span>, <span class="ruby-identifier">nchars_not_less</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># counter = nchars</span>
    <span class="ruby-identifier">nchars_not_less</span> <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, <span class="ruby-identifier">c</span>      <span class="ruby-comment"># a: inpoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, <span class="ruby-identifier">b</span>      <span class="ruby-comment"># c: counter min(nchars, nchars ready)</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">b</span>         <span class="ruby-comment"># b: counter - 1</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">b</span>         <span class="ruby-comment"># inpoffs = (inpoffs + counter - 1) % 256</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NC</span>, <span class="ruby-identifier">one_pass_only</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># save inpoffs</span>
                    <span class="ruby-identifier">cpl</span>             <span class="ruby-comment"># (-inpoffs - 1) % 256</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># ((-inpoffs - 1) % 256 + counter) % 256, CF: 1</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># reduced counter to the end of the i/o buffer</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>      <span class="ruby-comment"># restore inpoffs</span>
    <span class="ruby-identifier">one_pass_only</span>   <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-value">0</span>
                    <span class="ruby-identifier">ldir</span>            <span class="ruby-comment"># HL: -&gt; buffer, DE: -&gt; target</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NC</span>, <span class="ruby-identifier">no_2nd_pass</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, <span class="ruby-identifier">a</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># counter = inpoffs + 1</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">h</span>         <span class="ruby-comment"># rewind buffer</span>
                    <span class="ruby-identifier">ldir</span>            <span class="ruby-comment"># DE: -&gt; source + min(nchars, nchars ready)</span>
    <span class="ruby-identifier">no_2nd_pass</span>     <span class="ruby-identifier">pop</span>   <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; inpoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, [<span class="ruby-identifier">hl</span>]   <span class="ruby-comment"># prev inpoffs</span>
                    <span class="ruby-identifier">ld</span>    [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">a</span>   <span class="ruby-comment"># new inpoffs</span>
                    <span class="ruby-identifier">sub</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># written = new inpoffs - prev inpoffs</span>
    <span class="ruby-identifier">eop</span>             <span class="ruby-identifier">label</span>
                    <span class="ruby-identifier">ei</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span>
                    <span class="ruby-identifier">ret</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mtio_putc" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mtio_putc</span><span
            class="method-args">(char=e, tt:bc, not_ready: :eoc, subroutine: true, preserve_hl:true, disable_intr:true, enable_intr:true, mtyield: task_yield)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Writes a single character to the I/O buffer.</p>

<p>Arguments:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>char</code>
<dd>
<p>a number or an 8 bit register with the character code to be written.</p>
</dd></dl>
</li></ul>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>tt</code>
<dd>
<p>an 16 bit register for temporary use.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>not_ready</code>
<dd>
<p>what to do when a character can&#39;t be written. A symbol <code>:eoc</code> to just signal the failure with the CF flag reset (NC) and the ZF flag set (Z). A symbol <code>:wait</code> to wait until a character gets written. A label or an address to jump to when the character can&#39;t be written.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>subroutine</code>
<dd>
<p>if the routine should terminate with a <code>ret</code> instruction.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>preserve_hl</code>
<dd>
<p>if the routine should preserve the <code>hl</code> register via the stack.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more atomic actions.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>mtyield</code>
<dd>
<p>should contain an address of the kernel routine: <code>task_yield</code>.</p>
</dd></dl>
</li></ul>

<p>Expects:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an I/O buffer handle.</p>
</dd></dl>
</li></ul>

<p>On success the CF flag is set and the ZF flag is clear (NZ).</p>

<p>Modifies: <code>af</code>, <code>hl</code>, <code>tt</code>, preserves: <code>char</code>, optionally preserves: <code>hl</code> on the machine stack.</p>
          
          

          
          <div class="method-source-code" id="mtio_putc-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking_io.rb, line 549</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mtio_putc</span>(<span class="ruby-identifier">char</span>=<span class="ruby-identifier">e</span>, <span class="ruby-value">tt:</span><span class="ruby-identifier">bc</span>, <span class="ruby-value">not_ready:</span> <span class="ruby-value">:eoc</span>, <span class="ruby-value">subroutine:</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">preserve_hl:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">mtyield:</span> <span class="ruby-identifier">task_yield</span>)
  <span class="ruby-identifier">th</span>, <span class="ruby-identifier">tl</span> = <span class="ruby-identifier">tt</span>.<span class="ruby-identifier">split</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;char must not be a tl or th or h or l&quot;</span> <span class="ruby-keyword">if</span> [<span class="ruby-identifier">h</span>,<span class="ruby-identifier">l</span>,<span class="ruby-identifier">th</span>,<span class="ruby-identifier">tl</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">char</span>)
  <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">push</span>  <span class="ruby-identifier">hl</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">preserve_hl</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">th</span>, <span class="ruby-identifier">a</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">char</span><span class="ruby-operator">==</span><span class="ruby-identifier">a</span>
      <span class="ruby-identifier">repeat</span>        <span class="ruby-identifier">label</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, [<span class="ruby-identifier">hl</span>]   <span class="ruby-comment"># inpoffs</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">tl</span>, [<span class="ruby-identifier">hl</span>]  <span class="ruby-comment"># outoffs</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">tl</span>
                    <span class="ruby-identifier">cp</span>    <span class="ruby-identifier">tl</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">not_ready</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:eoc</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">enable_intr</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">preserve_hl</span>
                    <span class="ruby-identifier">ret</span>   <span class="ruby-constant">Z</span>
      <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">eop</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:wait</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">wait_busy</span>
      <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NZ</span>, <span class="ruby-identifier">skip</span>
                    <span class="ruby-identifier">call</span>  <span class="ruby-identifier">mtyield</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-identifier">repeat</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jp</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">not_ready</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">skip</span>            <span class="ruby-identifier">ld</span>    [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">tl</span>  <span class="ruby-comment"># outoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, <span class="ruby-identifier">th</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">char</span><span class="ruby-operator">==</span><span class="ruby-identifier">a</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">th</span>, <span class="ruby-value">-1</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">tt</span>
                    <span class="ruby-identifier">ld</span>    [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">char</span>
    <span class="ruby-identifier">eop</span>             <span class="ruby-identifier">label</span>
                    <span class="ruby-identifier">ei</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span>
                    <span class="ruby-identifier">pop</span>   <span class="ruby-identifier">hl</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">preserve_hl</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
                    <span class="ruby-identifier">ret</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">not_ready</span> <span class="ruby-operator">==</span> <span class="ruby-value">:wait</span>
    <span class="ruby-identifier">wait_busy</span>       <span class="ruby-identifier">call</span>  <span class="ruby-identifier">mtyield</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-identifier">repeat</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mtio_puts" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mtio_puts</span><span
            class="method-args">(nchars=a, check_nchars_zero:true, subroutine:true, disable_intr:true, enable_intr:true, mtyield: task_yield)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sends a string of characters to the I/O buffer.</p>

<p>Arguments:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>nchars</code>
<dd>
<p>a number 1..255 or accumulator with a number of characters to be sent.</p>
</dd></dl>
</li></ul>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>tt</code>
<dd>
<p>an 16 bit register for temporary use.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>check_nchars_zero</code>
<dd>
<p>a boolean indicating if the accumulator should be checked against 0.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>subroutine</code>
<dd>
<p>if the routine should terminate with a <code>ret</code> instruction.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more atomic actions.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>mtyield</code>
<dd>
<p>should contain an address of the kernel routine: <code>task_yield</code>.</p>
</dd></dl>
</li></ul>

<p>Expects:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an I/O buffer handle.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>de</code>
<dd>
<p>an address of the string to be send.</p>
</dd></dl>
</li></ul>

<p>On success accumulator contains the number of characters successfully sent. If its value is 0 the ZF flag is also set indicating that no characters has been sent at all. Preserves <code>hl</code> registers. <code>de</code> will be incremented by the number of characters sent.</p>

<p>Modifies: <code>af</code>, <code>af&#39;</code>, <code>de</code>, <code>bc</code> and uses stack to preserve <code>hl</code>.</p>
          
          

          
          <div class="method-source-code" id="mtio_puts-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking_io.rb, line 710</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mtio_puts</span>(<span class="ruby-identifier">nchars</span>=<span class="ruby-identifier">a</span>, <span class="ruby-value">check_nchars_zero:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">subroutine:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">mtyield:</span> <span class="ruby-identifier">task_yield</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;nchars must be accumulator or an integer: 1..255&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">nchars</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a</span> <span class="ruby-keyword">or</span> (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">255</span>).<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">nchars</span>)
  <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eoc</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nchars</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">check_nchars_zero</span>
                    <span class="ruby-identifier">anda</span>  <span class="ruby-identifier">a</span>         <span class="ruby-comment"># nchars == 0</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
                    <span class="ruby-identifier">ret</span>   <span class="ruby-constant">Z</span>
        <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">eoc</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
                    <span class="ruby-identifier">ex</span>    <span class="ruby-identifier">af</span>, <span class="ruby-identifier">af</span>
    <span class="ruby-keyword">end</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, [<span class="ruby-identifier">hl</span>]   <span class="ruby-comment"># -&gt; inpoffs</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, [<span class="ruby-identifier">hl</span>]   <span class="ruby-comment"># -&gt; outoffs</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># c: outoffs + 1</span>
                    <span class="ruby-identifier">sub</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># a: buffer free</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">Z</span>, <span class="ruby-identifier">eop</span>    <span class="ruby-comment"># no room to write</span>
                    <span class="ruby-identifier">push</span>  <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; outoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-value">-1</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">hl</span>, <span class="ruby-identifier">bc</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># b: buffer free</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nchars</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">a</span>
                    <span class="ruby-identifier">ex</span>    <span class="ruby-identifier">af</span>, <span class="ruby-identifier">af</span>
    <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, <span class="ruby-identifier">nchars</span>
    <span class="ruby-keyword">end</span>
                    <span class="ruby-identifier">cp</span>    <span class="ruby-identifier">b</span>         <span class="ruby-comment"># nchars &lt; buffer free</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NC</span>, <span class="ruby-identifier">nchars_not_less</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># counter = nchars</span>
    <span class="ruby-identifier">nchars_not_less</span> <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, <span class="ruby-identifier">c</span>      <span class="ruby-comment"># a: outoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, <span class="ruby-identifier">b</span>      <span class="ruby-comment"># c: counter min(nchars, buffer free)</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">b</span>         <span class="ruby-comment"># b: counter - 1</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">b</span>         <span class="ruby-comment"># outoffs = (outoffs + counter - 1) % 256</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NC</span>, <span class="ruby-identifier">one_pass_only</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># save outoffs</span>
                    <span class="ruby-identifier">cpl</span>             <span class="ruby-comment"># (-outoffs - 1) % 256</span>
                    <span class="ruby-identifier">add</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># ((-outoffs - 1) % 256 + counter) % 256, CF: 1</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, <span class="ruby-identifier">a</span>      <span class="ruby-comment"># reduced counter to the end of the i/o buffer</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>      <span class="ruby-comment"># restore outoffs</span>
    <span class="ruby-identifier">one_pass_only</span>   <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">b</span>, <span class="ruby-value">0</span>
                    <span class="ruby-identifier">ex</span>    <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>    <span class="ruby-comment"># DE: -&gt; buffer, HL: -&gt; source</span>
                    <span class="ruby-identifier">ldir</span>
                    <span class="ruby-identifier">jr</span>    <span class="ruby-constant">NC</span>, <span class="ruby-identifier">no_2nd_pass</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, <span class="ruby-identifier">a</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># counter = outoffs + 1</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">d</span>         <span class="ruby-comment"># rewind buffer</span>
                    <span class="ruby-identifier">ldir</span>
    <span class="ruby-identifier">no_2nd_pass</span>     <span class="ruby-identifier">ex</span>    <span class="ruby-identifier">de</span>, <span class="ruby-identifier">hl</span>    <span class="ruby-comment"># DE: -&gt; source + min(nchars, buffer free)</span>
                    <span class="ruby-identifier">pop</span>   <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; outoffs</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">c</span>, [<span class="ruby-identifier">hl</span>]   <span class="ruby-comment"># prev outoffs</span>
                    <span class="ruby-identifier">ld</span>    [<span class="ruby-identifier">hl</span>], <span class="ruby-identifier">a</span>   <span class="ruby-comment"># new outoffs</span>
                    <span class="ruby-identifier">sub</span>   <span class="ruby-identifier">c</span>         <span class="ruby-comment"># written = new outoffs - prev outoffs</span>
    <span class="ruby-identifier">eop</span>             <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>        <span class="ruby-comment"># -&gt; inpoffs</span>
                    <span class="ruby-identifier">ei</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span>
                    <span class="ruby-identifier">ret</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">subroutine</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mtio_ready-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mtio_ready?</span><span
            class="method-args">(action, nchars:nil, disable_intr:true, enable_intr:true)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Checks I/O buffer&#39;s data availability.</p>

<p>Arguments:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>action</code>
<dd>
<p>a symbol <code>:read</code> to get the information if the data is ready to be read, a symbol <code>:write</code> to get the information if the data can be written.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>nchars</code>
<dd>
<p><code>nil</code> to get a simple boolean answer or a number or an 8 bit register which should contain a number of characters that should be available for reading or writing.</p>
</dd></dl>
</li></ul>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more atomic actions.</p>
</dd></dl>
</li></ul>

<p>Expects:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an I/O buffer handle.</p>
</dd></dl>
</li></ul>

<p>Depending on the selected action and whether <code>nchars</code> option was <code>nil</code> or not, on return:</p>

<pre>action    nchars      status     flags      accumulator
 *any*       nil      not ready  ZF=1 (Z)   0
 :read       nil      ready      ZF=0 (NZ)  no of characters ready to be read &lt;= 255
:write       nil      ready      ZF=0 (NZ)  no of characters already written + 1 &lt;= 255
 :read    number      not ready  CF=1 (C)   no of characters ready to be read &lt; nchars
 :read    number      ready      CF=0 (NC)  no of characters ready to be read &gt;= nchars
:write    number      not ready  CF=1 (C)   no of characters that won&#39;t fit into the buffer - 1 &lt; nchars
:write    number      ready      CF=0 (NC)  no of characters already written + nchars &lt;= 255</pre>

<p>Modifies: <code>af</code>, preserves: <code>hl</code> and <code>nchars</code>.</p>
          
          

          
          <div class="method-source-code" id="mtio_ready-3F-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking_io.rb, line 369</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mtio_ready?</span>(<span class="ruby-identifier">action</span>, <span class="ruby-value">nchars:</span><span class="ruby-keyword">nil</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;action must be one of: :read or :write&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">action</span><span class="ruby-operator">==</span><span class="ruby-value">:read</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">action</span><span class="ruby-operator">==</span><span class="ruby-value">:write</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;nchars must not be one of: a, h nor l&quot;</span> <span class="ruby-keyword">if</span> [<span class="ruby-identifier">a</span>, <span class="ruby-identifier">h</span>, <span class="ruby-identifier">l</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">nchars</span>)
  <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span>
                    <span class="ruby-identifier">dec</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">ld</span>    <span class="ruby-identifier">a</span>, [<span class="ruby-identifier">hl</span>] <span class="ruby-comment"># outoffs</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">hl</span>
                    <span class="ruby-identifier">ei</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">enable_intr</span>
                    <span class="ruby-identifier">sub</span>   [<span class="ruby-identifier">hl</span>] <span class="ruby-comment"># inpoffs</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nchars</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">action</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:read</span>
                    <span class="ruby-identifier">cp</span>   <span class="ruby-identifier">nchars</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:write</span>
                    <span class="ruby-identifier">add</span>  <span class="ruby-identifier">nchars</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
                    <span class="ruby-identifier">inc</span>   <span class="ruby-identifier">a</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">action</span> <span class="ruby-operator">==</span> <span class="ruby-value">:write</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mtio_wait" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mtio_wait</span><span
            class="method-args">(action, nchars=1, disable_intr:true, enable_intr:true, mtyield:task_yield)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Waits for the I/O buffer&#39;s data availability.</p>

<p>Arguments:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>action</code>
<dd>
<p>a symbol <code>:read</code> to wait for the data to be read, a symbol <code>:write</code> to wait for the data to be written.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>nchars</code>
<dd>
<p>a number or an 8 bit register which should contain a number of characters that should be available for reading or writing.</p>
</dd></dl>
</li></ul>

<p>Options:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>disable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should disable interrupts. Provide <code>false</code> only if you have already disabled the interrupts.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>enable_intr</code>
<dd>
<p>a boolean flag indicating that the routine should enable interrupts. Provide <code>false</code> if you need to perform more atomic actions.</p>
</dd></dl>
</li><li><dl class="rdoc-list note-list"><dt><code>mtyield</code>
<dd>
<p>should contain an address of the kernel routine: <code>task_yield</code>.</p>
</dd></dl>
</li></ul>

<p>Expects:</p>
<ul><li><dl class="rdoc-list note-list"><dt><code>hl</code>
<dd>
<p>an I/O buffer handle.</p>
</dd></dl>
</li></ul>

<p>On return a CF flag always cleared and accumulator contains a number of characters ready to be read or a number of characters already written + nchars.</p>

<p>Modifies: <code>af</code>, preserves: <code>hl</code> and <code>nchars</code>.</p>
          
          

          
          <div class="method-source-code" id="mtio_wait-source">
            <pre><span class="ruby-comment"># File lib/zxutils/multitasking_io.rb, line 413</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mtio_wait</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">nchars</span>=<span class="ruby-value">1</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-keyword">true</span>, <span class="ruby-value">mtyield:</span><span class="ruby-identifier">task_yield</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;nchars must not be nil&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">nchars</span>.<span class="ruby-identifier">nil?</span>
  <span class="ruby-identifier">isolate</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">eoc</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">check_ready</span>     <span class="ruby-identifier">mtio_ready?</span>(<span class="ruby-identifier">action</span>, <span class="ruby-value">nchars:</span><span class="ruby-identifier">nchars</span>, <span class="ruby-value">disable_intr:</span><span class="ruby-identifier">disable_intr</span>, <span class="ruby-value">enable_intr:</span><span class="ruby-identifier">enable_intr</span>)
                    <span class="ruby-identifier">jr</span>   <span class="ruby-constant">NC</span>, <span class="ruby-identifier">eoc</span>
                    <span class="ruby-identifier">call</span> <span class="ruby-identifier">mtyield</span>
                    <span class="ruby-identifier">di</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">disable_intr</span>
                    <span class="ruby-identifier">jr</span>   <span class="ruby-identifier">check_ready</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

